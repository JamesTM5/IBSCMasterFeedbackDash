---
title: "IBSC School Dashboard"
output:
  flexdashboard::flex_dashboard:
    orientation: columns
    social: menu
    vertical_layout: fill
runtime: shiny
resource_files:
- assets/d3.min.js
- assets/forcedirected/binding.js
- assets/forcedirected/fd.js
- assets/forcedirected/repeated-fd.js
- assets/forcedirected/styles.css
---

```{r setup, include=FALSE}
source("clientConfig.R")
#on first pull, install any uninstalled packages in packageSetup.R
source("packageSetup.R")

#on first pull, move the .xlsx sheets into the directory, rename them in the
#format "*.Student<class name>.xlsx" and run SchoolDataPrep.R to generate the
#.RDS files in the working directory needed by the dash.  This file need not be
#deployed to increase speed and safeguard alghorithms.

#Read in all .RDS files in the working directory
files = list.files(path = '.', pattern = '^.*rds$')
fileList <- list()
for (i in 1:length(files)) {
  file <- readRDS(files[i])
  name <- as.character(files[i])
  fileList[[name]] <- file
}

set.seed (fileList[[1]]$seed)

#convenience function to find out if a graph is fragmented.
graphConnected <- function(graph) {
  CD <- component_distribution(graph)
  if(length(CD[!CD==0])>1) {
    connected <- FALSE
  } else {
    connected <- TRUE
  }
}

#Convenience wrapper for raw data with download options
create_dt <- function(x){
  DT::datatable(x,
                extensions = 'Buttons',
                options = list(dom = 'Blfrti',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(50,100, 200, -1),
                                                 c(50, 100, 200, "All")),
                               paginate = TRUE
                               )
               )
}

# make a colour palette
  listOfColours <- c("#9E0142", "#66c2a5", "#C99f47","#D55E00", "#0072B2",
                     "#332288", "#661100")
# make it d3 compatible
  colors <- paste(sapply(listOfColours, function(x) {
    paste0("d3.rgb(",paste(c(col2rgb(x), 0.5),
                           collapse = "," ),
           ")") }),
    collapse = ", ")
  colorJS <- paste0('d3.scaleOrdinal([', colors, '])')
  

#Prep the data for the D3 maps
  
collateData <- function(file, number) {
  nodes <- file$D3NodesList[[number]]
  edges <- file$edgeDataList[[number]]
  t <- list(nodes = nodes, edges = edges)
}

prepData <- function(fileSet, index) {
  First <- collateData(fileSet, number = index)
  #Second <- collateData(fileSet, number = (index+1))
  JSONOut <- list(First = First)
  #JSONOut <- list(First = First, Second = Second)
}

#run d3 prep for all classes in the organisation
for(i in 1:length(fileList)) {
  #run d3 prep for all relationship questions in each class
  for (j in 1:length(fileList[[i]]$D3NodesList)) {
    fileName <- paste("D3JSData",j, i, ".json", sep = "")
    D3JSData <- prepData(fileSet = fileList[[i]], index = j)
    D3JSData <- jsonlite::toJSON(D3JSData)
    write(D3JSData, fileName)
  }
}

#source the D3 code to link the R to JS
source("assets/forcedirected/forcedirected.R")

#set up Belongingness Dashboard
dataFileBelongingness <- fileList[[1]]$belongingnessDF
unprocessedBelongingnessData <- dataFileBelongingness
WBNumeric <- dataFileBelongingness
GBChoices <- as.list(names(WBNumeric))
  names(GBChoices) <- paste(names(WBNumeric), " (", map(WBNumeric,~length(unique(.x))), ")") 
belongingnessFontSize <- "9pt"
metricChoices <- names(select_if(WBNumeric, is.numeric))
GBChoices <- GBChoices [!GBChoices %in% metricChoices]

#significance testing for belongingness dashboard
#A function to find significant differences between factors in the belongingness survey

belongingnessSignificanceTesting <- function (data){

#prep data for analysis
  prunedDataSDV <- data %>% discard(is.numeric)
  prunedDataExperimental <- data %>% keep(is.numeric)
  #make sure each column of prunedDataSDV is class(factor)
  for(i in 1:ncol(prunedDataSDV)) {
    prunedDataSDV[,i] <- as.factor(prunedDataSDV[,i])
  }
  #remove "id" from the first column
  prunedDataSDV <- prunedDataSDV[,-1]
  #remove belongingness Stratified
  prunedDataSDV <- subset(prunedDataSDV, select = -`Belongingness Stratified`)

#initiate some lists
  significance <- list()
  significantPredictors <- list()
  interactionEffects <- list()
  predictors <- list()
  
  
#Choose the right comparison of means test
  #compare each subset of each sdv with every single experimental variable
  for (i in 1:ncol(prunedDataSDV)){
    for (j in 1:ncol(prunedDataExperimental)) {
  #if predictor categorical
      if (class(prunedDataSDV[[i]]) == "factor") {
          x <- prunedDataExperimental[[j]]
          y <- as.numeric(as.factor(as.character(prunedDataSDV[[i]])))
          #t-test
          if(length(levels(prunedDataSDV[[i]])) <= 2) {
            tt <- t.test(x ~ y)
            result <- tt$p.value
          #ANOVA
          } else if (length(levels(prunedDataSDV[[i]])) >2) {
            anova <- aov(x ~ y)
            #TODO: check for balance with replications function
            result <- summary(anova)[[1]][["Pr(>F)"]][[1]]
          }
          resultName <- paste(names(prunedDataExperimental)[j], "by", 
                              names(prunedDataSDV)[i], sep = " ")
          names(result) <- resultName
          significance <- append(result, significance)
          if (result < .01) {
            significantPredictor <- "Highly Significant"
            names(significantPredictor) <- paste(names(prunedDataExperimental)[j], "by", 
                                                 names(prunedDataSDV)[i], sep = " ")
            significantPredictors <- append(significantPredictor,
                                            significantPredictors)
            predictors <- append(names(prunedDataSDV)[i], predictors)
          } else if (result < .05) {
            significantPredictor <- "Significant"
            names(significantPredictor) <- paste(names(prunedDataExperimental)[j], "by", 
                                                 names(prunedDataSDV)[i], sep = " ")
            significantPredictors <- append(significantPredictor,
                                            significantPredictors)
            predictors <- append(names(prunedDataSDV)[i], predictors)
          }
        } else {
        cat ("data in an unsupported format")
       }
    }
  }
  
  #For every predictive variable, pair it with every other SDV in turn and look for an interaction effect
  
  #find every unique combination of those SDVs
  expand.grid.unique <- function(x, y, include.equals=FALSE) {
    x <- unique(x)
    y <- unique(y)
    g <- function(i) {
      z <- setdiff(y, x[seq_len(i-include.equals)])
      if(length(z)) cbind(x[i], z, deparse.level=0)
    }
    do.call(rbind, lapply(seq_along(x), g))
  }
  
  ANOVACombos <- expand.grid.unique(predictors, names(prunedDataSDV))
  
#for every unique combination of 2 SDV combo see if there is highly significant predictive power
  
  for (k in 1:nrow(ANOVACombos)) {
      SDV1 <- unlist(ANOVACombos[k,1])
      SDV2 <- unlist(ANOVACombos[k,2])
      EV <- prunedDataExperimental$`Belongingness Mean`
      if((class(prunedDataSDV[[SDV1]]) == "factor") && (class(prunedDataSDV[[SDV2]]) == "factor")) {
        #perform a 2 way ANOVA
        IE <- aov(EV ~ prunedDataSDV[[SDV1]] * prunedDataSDV[[SDV2]])
        pvalues <- summary(IE)[[1]][["Pr(>F)"]]
        resultSDV1 <- pvalues[1]
        resultSDV2 <- pvalues[2]
        interactionEffect <- pvalues[3]
        if (is.na(resultSDV1) || is.na(resultSDV2)) {
          
        } else if (resultSDV1 > .05 || resultSDV2 > .05) {
          if(is.na(interactionEffect)) {
            
          } else if (interactionEffect < .01) {
            significantPredictor <- "Highly Significant"
            resultName <- paste(names(prunedDataExperimental)[j], "by", 
                                SDV1, "and", SDV2, sep = " ")
            names(significantPredictor) <- resultName
            interactionEffects <- append(significantPredictor,
                                         interactionEffects)
          } else if (interactionEffect > .05) {
            significantPredictor <- "Significant"
            resultName <- paste(names(prunedDataExperimental)[j], "by", 
                                SDV1, "and", SDV2, sep = " ")
            names(significantPredictor) <- resultName
          }
        }
      }
    
  }
  
   return( list(significantPredictors, interactionEffects))
  #TODO: if predictor variable quantitative, figure out the right regression analysis
}

significantPredictors <- belongingnessSignificanceTesting(unprocessedBelongingnessData)
interactionEffects <- significantPredictors[[2]]
significantPredictors <- significantPredictors[[1]]

#prep significance data for display
predictionTable <- data.table::setDT(significantPredictors)
values <- str_split(colnames(predictionTable), " by ")
cols <- list()
rows <- list()

for (i in 1:length(values)) {
  first <- values[[i]] [1]
  second <- values [[i]] [2]
  cols <- append(cols, first)
  rows <- append(rows, second)
}

valueTable <- rbind(predictionTable, rows)
valueTable <- rbind(valueTable, cols)

strengthTable <- data.frame(matrix(ncol = length(unique(unlist(cols))), nrow = 
                                length(unique(unlist(rows)))))
colnames(strengthTable) <- unique(unlist(cols))
rownames(strengthTable) <- unique(unlist(rows))

SDVTable <- data.frame(matrix(ncol = length(unique(unlist(cols))), nrow = 
                                length(unique(unlist(rows)))))
colnames(SDVTable) <- unique(unlist(cols))
rownames(SDVTable) <- unique(unlist(rows))

for (i in 1:ncol(valueTable)) {
  colName1 <- as.character(valueTable[3,..i])
  rowName1 <- as.character(valueTable[2,..i])
  strengthTable[rowName1, colName1] <- valueTable[1,..i]
}

for (i in 1:ncol(valueTable)) {
  colName1 <- as.character(valueTable[3,..i])
  rowName1 <- as.character(valueTable[2,..i])
  SDVTable[rowName1, colName1] <- valueTable[2,..i]
}
```


Student - Student Interaction Positivity {data-navmenu="Class Name"}
=======================================================================
  
Headlines {data-width=200}
--------------------------------------------------------------------------

### Question Statement: This person and I have frequent positive interactions either in class or outside class

```{r}
valueBox(
  "Positivity",
  caption = NULL,
  color = '#186ecc',
  icon = "fa-comment"
)
```

### {-}

```{r}
valueBox(
  fileList[[1]]$className,
  caption = NULL,
  color = '#186ecc',
  icon = "fa-chalkboard-teacher"
)
```

### Network Health

```{r}
valueBox(
  fileList[[1]]$overallHealth[[1]][[1]],
  color = fileList[[1]]$overallHealth[[1]][[2]],
  icon = "fa-file-medical"
)
```

### Potential for Improvement

```{r}
valueBox(
  fileList[[1]]$overallPfI[[1]][[1]],
  color = fileList[[1]]$overallPfI[[1]][[2]],
  icon = "fa-chart-line"
)
```

### Our Commentary

  The data shown here is a result of analysis conducted upon the social
network data provided by completing our Relationships Foundation
Questionnaires, along with any other information provided to us by you
and/or `r fileList[[1]]$clientName`.

  Our analysis shows this class to be moderately healthy and with a moderate potential for improvement.

### Class Predictive Factors

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$homophylyList[[1]][[1]] > 0)) {
  cat(fileList[[1]]$homophylyList[[1]][[1]])
} else {
  cat("None")
}
```
</center>

>These factors statistically significantly influence the nature and function of the class

### Class Indeterminate Factors

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$homophylyList[[1]][[3]] > 0)) {
  cat(fileList[[1]]$homophylyList[[1]][[3]])
} else {
  cat("None")
}
```
</center>

>These factors could not be shown to influence the nature and function of the class at a peer-to-peer level due to limitations in the data collected

### Class Non-Predictive Factors

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$homophylyList[[1]][[2]] > 0)) {
  cat(fileList[[1]]$homophylyList[[1]][[2]])
} else {
  cat("None")
}
```
</center>

>These factors do not statistically significantly influence the nature and
function of the class

Row {data-width=250}
-----------------------------------------------------------------------

### Class Diameter

```{r}
diameter <- fileList[[1]]$totalNetworkInfo[[1]][[4]]
nodes <- length(fileList[[1]]$totalNetworkInfo[[1]][[10]])

# derive sector colours for gauge from nrow(nodes) and whether
# the graph is fragmented

if(graphConnected(fileList[[1]]$SSNQGraph[[1]])== F) {
  customSectors <-  gaugeSectors (
    danger = c(0, 100)
  )
} else {
  customSectors <-  gaugeSectors (
    success = c(0,(nodes/6)),
    warning = c((nodes/6), (nodes/3)),
    danger = c((nodes/3), (nodes/2)))
}

#make gauge
gauge(round(diameter, digits = 2), min = 1, max = (nodes/2), sectors = customSectors)

#provide warning text if graph is fragmented.
if (graphConnected(fileList[[1]]$SSNQGraph[[1]]) == F) {
  SSNQConnectedWarning <- paste("However, as this group is split across ",
    "separate unconnected sub-groups, this may not be a good measure of group ",
    "cohesiveness.",
    sep = "")
} else {
  SSNQConnectedWarning <- ""
}
```
 
> The most distant people are `r round(diameter, digits=0)` relationships away
from each other. <span style="color: red;">`r SSNQConnectedWarning`</span> 

### Percentage of Positive Relationships

```{r}
edgeDensity <- fileList[[1]]$totalNetworkInfo[[1]][[5]]
edgeDensityPercentage <- round((edgeDensity*100), digits = 0)
gauge(edgeDensityPercentage, min = 0, max = 100, symbol = '%', gaugeSectors(
    success = c(21, 100), 
    warning = c(16, 20), 
    danger = c(0, 15)
  ))
```
  
> `r round(edgeDensity, digits = 2)*100`% of all possible relationships are
strongly positive.
  
### Class Reciprocity
  
```{r}
reciprocity <- fileList[[1]]$totalNetworkInfo[[1]][[6]]
reciprocityPercentage <- round((reciprocity*100), digits = 0)
gauge(reciprocityPercentage, min = 0, max = 100, symbol = '%', gaugeSectors(
    success = c(55, 100), 
    warning = c(40, 54), 
    danger = c(0, 39)
  ))
```

> Both parties agreed on a relationship status
`r round(reciprocity, digits = 2)*100`% of the time.

### Class Communities Dendrogram  {data-height=400} 
<center>
```{r}

fileList[[1]]$dendrogramList[[1]]

```
</center>

> This shows how the relational landscape divides into subgroups, mirrored in the colour of the dots on the summary graph.  The higher the number on the left, the bigger the distance between the group members attached at the split.
  

Network Maps 
----------------------------------------------------------------

### Summary graph {.no-padding data-height=700} 

```{r}

JSData1 <- jsonlite::read_json("D3JSData11.json")

repeatedforcedirectedOutput("repeatedforcedirected1")
output$repeatedforcedirected1 <- renderRepeatedforcedirected(repeatedforcedirected("Hello", JSData1))
```

> The lines on this graph represent the strongest relationships in the class. Each dot is a person, and each line is a strong relationship. The colours indicate cliques, or subgroups in the data which naturally form as people form and maintain social networks. Zoom using the scroll wheel or pinch on a touchscreen device, and drag people around to see who is connected most closely to them. The position on the graph doesn't matter itself, its about the position relative to the other people and how linked in they are with the group as a whole.

Key Network Information {data-width=250}
-----------------------------------------------------

### Class 'Hubs' {data-height=350} 

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$HSList[[1]]) > 0) {
  cat(fileList[[1]]$HSList[[1]])
} else {
  cat("Contact Volume Hub Analysis Encountered an Error")
}
```
</center>

> These people are the lifeblood of the class: Their absence would hamper communication and they make good contacts for new members to get more integrated.  They are those who report the most highly positive relationships with others.

### Class 'Authorities' {data-height=350} 

<center>
```{r, results = 'asis'}
if (length(as.character(fileList[[1]]$ASList[[1]]) > 0)) {
  cat(fileList[[1]]$ASList[[1]])
} else {
  cat("Network Authority Analysis Encountered an Error")
}
```
</center>

>These tend to be the class members who are  looked up to, or approached for advice or information by their peers: They have high value to others in the group.  They are those whom others identify as having the most highly positive relationships with.

### Fundamental Relationships  {data-height=750}

<center>
```{r, results = 'asis'}
cat(paste(fileList[[1]]$totalNetworkInfo[[1]][[9]][1,1], "<br>", "and<br>",
          fileList[[1]]$totalNetworkInfo[[1]][[9]][1,2])
    )
```

***

```{r, results = 'asis'}
cat(paste(fileList[[1]]$totalNetworkInfo[[1]][[9]][2,1], "<br>", "and<br>",
          fileList[[1]]$totalNetworkInfo[[1]][[9]][2,2])
    )
```

***

```{r, results = 'asis'}
cat(paste(fileList[[1]]$totalNetworkInfo[[1]][[9]][3,1], "<br>", "and<br>",
          fileList[[1]]$totalNetworkInfo[[1]][[9]][3,2])
    )
```
</center>

>These are the relationships which make the class operate as it does.  Promoting
these adds cohesion.

### Network Isolates

<center>
```{r, results = 'asis'}
if(!is.null(fileList[[1]]$isolatesList[[1]])) {
  cat(fileList[[1]]$isolatesList[[1]])
}
```
</center>

>These people are not joined to any others in the network by positive
relationships in at least one of the dimensions they were asked about.

Student - Student Knowing One Another {data-navmenu="Class Name"}
=======================================================================
  
Headlines {data-width=200}
--------------------------------------------------------------------------

### Question Statement: I am confident that this person and I know each other's skills and interests

```{r}
valueBox(
  "Knowing",
  caption = NULL,
  color = '#186ecc',
  icon = "fa-comment"
)
```


### {-}

```{r}
valueBox(
  fileList[[1]]$className,
  caption = NULL,
  color = '#186ecc',
  icon = "fa-chalkboard-teacher"
)
```

### Network Health

```{r}
valueBox(
  fileList[[1]]$overallHealth[[2]][[1]],
  color = fileList[[1]]$overallHealth[[2]][[2]],
  icon = "fa-file-medical"
)
```

### Potential for Improvement

```{r}
valueBox(
  fileList[[1]]$overallPfI[[2]][[1]],
  color = fileList[[1]]$overallPfI[[2]][[2]],
  icon = "fa-chart-line"
)
```

### Our Commentary

  The data shown here is a result of analysis conducted upon the social
network data provided by completing our Relationships Foundation
Questionnaires, along with any other information provided to us by you
and/or `r fileList[[1]]$clientName`.

  Our analysis shows this class to be moderately healthy and with a moderate potential for improvement.
  
### Class Predictive Factors

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$homophylyList[[2]][[1]] > 0)) {
  cat(fileList[[1]]$homophylyList[[2]][[1]])
} else {
  cat("None")
}
```
</center>

>These factors statistically significantly influence the nature and function of the class


### Class Indeterminate Factors

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$homophylyList[[2]][[3]] > 0)) {
  cat(fileList[[1]]$homophylyList[[2]][[3]])
} else {
  cat("None")
}
```
</center>

>These factors could not be shown to influence the nature and function of the class at a peer-to-peer level due to limitations in the data collected

### Class Non-Predictive Factors

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$homophylyList[[2]][[2]] > 0)) {
  cat(fileList[[1]]$homophylyList[[2]][[2]])
} else {
  cat("None")
}
```
</center>

>These factors do not statistically significantly influence the nature and
function of the class
  
Row {data-width=250}
-----------------------------------------------------------------------

### Class Diameter

```{r}
diameter <- fileList[[1]]$totalNetworkInfo[[2]][[4]]
nodes <- length(fileList[[1]]$totalNetworkInfo[[2]][[10]])

# derive sector colours for gauge from nrow(nodes) and whether
# the graph is fragmented

if(graphConnected(fileList[[1]]$SSNQGraph[[2]])== F) {
  customSectors <-  gaugeSectors (
    danger = c(0, 100)
  )
} else {
  customSectors <-  gaugeSectors (
    success = c(0,(nodes/6)),
    warning = c((nodes/6), (nodes/3)),
    danger = c((nodes/3), (nodes/2)))
}

#make gauge
gauge(round(diameter, digits = 2), min = 1, max = (nodes/2), sectors = customSectors)

#provide warning text if graph is fragmented.
if (graphConnected(fileList[[1]]$SSNQGraph[[2]]) == F) {
  SSNQConnectedWarning <- paste("However, as this group is split across ",
    "separate unconnected sub-groups, this may not be a good measure of group ",
    "cohesiveness.",
    sep = "")
} else {
  SSNQConnectedWarning <- ""
}
```
 
> The most distant people are `r round(diameter, digits=0)` relationships away
from each other. <span style="color: red;">`r SSNQConnectedWarning`</span> 

### Percentage of Positive Relationships

```{r}
edgeDensity <- fileList[[1]]$totalNetworkInfo[[2]][[5]]
edgeDensityPercentage <- round((edgeDensity*100), digits = 0)
gauge(edgeDensityPercentage, min = 0, max = 100, symbol = '%', gaugeSectors(
    success = c(21, 100), 
    warning = c(16, 20), 
    danger = c(0, 15)
  ))
```
  
> `r round(edgeDensity, digits = 2)*100`% of all possible relationships are
strongly positive.
  
### Class Reciprocity
  
```{r}
reciprocity <- fileList[[1]]$totalNetworkInfo[[2]][[6]]
reciprocityPercentage <- round((reciprocity*100), digits = 0)
gauge(reciprocityPercentage, min = 0, max = 100, symbol = '%', gaugeSectors(
    success = c(55, 100), 
    warning = c(40, 54), 
    danger = c(0, 39)
  ))
```

> Both parties agreed on a relationship status
`r round(reciprocity, digits = 2)*100`% of the time.

### Class Communities Dendrogram  {data-height=400} 
<center>
```{r}

fileList[[1]]$dendrogramList[[2]]

```
</center>

> This shows how the relational landscape divides into subgroups, mirrored in the colour of the dots on the summary graph.  The higher the number on the left, the bigger the distance between the group members attached at the split.

Network Maps 
----------------------------------------------------------------

### Summary graph {.no-padding data-height=700} 

```{r}

JSData2 <- jsonlite::read_json("D3JSData21.json")

repeatedforcedirectedOutput("repeatedforcedirected2")
output$repeatedforcedirected2 <- renderRepeatedforcedirected(repeatedforcedirected("Hello", JSData2))

```

> The lines on this graph represent the strongest relationships in the class. Each dot is a person, and each line is a strong relationship. The colours indicate cliques, or subgroups in the data which naturally form as people form and maintain social networks. Zoom using the scroll wheel or pinch on a touchscreen device, and drag people around to see who is connected most closely to them. The position on the graph doesn't matter itself, its about the position relative to the other people and how linked in they are with the group as a whole.

Key Network Information {data-width=250}
-----------------------------------------------------

### Class 'Hubs' {data-height=350} 

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$HSList[[2]]) > 0) {
  cat(fileList[[1]]$HSList[[2]])
} else {
  cat("Contact Volume Hub Analysis Encountered an Error")
}
```
</center>

> These people are the lifeblood of the class: Their absence would hamper communication and they make good contacts for new members to get more integrated.  They are those who report the most highly positive relationships with others.

### Class 'Authorities' {data-height=350} 

<center>
```{r, results = 'asis'}
if (length(as.character(fileList[[1]]$ASList[[2]]) > 0)) {
  cat(fileList[[1]]$ASList[[2]])
} else {
  cat("Network Authority Analysis Encountered an Error")
}
```
</center>

>These tend to be the class members who are  looked up to, or approached for advice or information by their peers: They have high value to others in the group.  They are those whom others identify as having the most highly positive relationships with.

### Fundamental Relationships  {data-height=750}

<center>
```{r, results = 'asis'}
cat(paste(fileList[[1]]$totalNetworkInfo[[2]][[9]][1,1], "<br>", "and<br>",
          fileList[[1]]$totalNetworkInfo[[2]][[9]][1,2])
    )
```

***

```{r, results = 'asis'}
cat(paste(fileList[[1]]$totalNetworkInfo[[2]][[9]][2,1], "<br>", "and<br>",
          fileList[[1]]$totalNetworkInfo[[2]][[9]][2,2])
    )
```

***

```{r, results = 'asis'}
cat(paste(fileList[[1]]$totalNetworkInfo[[2]][[9]][3,1], "<br>", "and<br>",
          fileList[[1]]$totalNetworkInfo[[2]][[9]][3,2])
    )
```
</center>

>These are the relationships which make the class operate as it does.  Promoting
these adds cohesion.

### Network Isolates

<center>
```{r, results = 'asis'}
if(!is.null(fileList[[1]]$isolatesList[[2]])) {
  cat(fileList[[1]]$isolatesList[[2]])
}
```
</center>

>These people are not joined to any others in the network by positive
relationships in at least one of the dimensions they were asked about.


Student - Student Value and Respect {data-navmenu="Class Name"}
=======================================================================
  
Headlines {data-width=200}
--------------------------------------------------------------------------

### Question Statement: I feel that this person values and respects my contributions in class

```{r}
valueBox(
  "Valuing",
  caption = NULL,
  color = '#186ecc',
  icon = "fa-comment"
)
```


### {-}

```{r}
valueBox(
  fileList[[1]]$className,
  caption = NULL,
  color = '#186ecc',
  icon = "fa-chalkboard-teacher"
)
```

### Network Health

```{r}
valueBox(
  fileList[[1]]$overallHealth[[3]][[1]],
  color = fileList[[1]]$overallHealth[[3]][[2]],
  icon = "fa-file-medical"
)
```

### Potential for Improvement

```{r}
valueBox(
  fileList[[1]]$overallPfI[[3]][[1]],
  color = fileList[[1]]$overallPfI[[3]][[2]],
  icon = "fa-chart-line"
)
```

### Our Commentary

  The data shown here is a result of analysis conducted upon the social
network data provided by completing our Relationships Foundation
Questionnaires, along with any other information provided to us by you
and/or `r fileList[[1]]$clientName`.

  Our analysis shows this class to be moderately healthy and with a moderate potential for improvement.
  

### Class Predictive Factors

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$homophylyList[[3]][[1]] > 0)) {
  cat(fileList[[1]]$homophylyList[[3]][[1]])
} else {
  cat("None")
}
```
</center>

>These factors statistically significantly influence the nature and function of the class

### Class Indeterminate Factors

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$homophylyList[[3]][[3]] > 0)) {
  cat(fileList[[1]]$homophylyList[[3]][[3]])
} else {
  cat("None")
}
```
</center>

>These factors could not be shown to influence the nature and function of the class at a peer-to-peer level due to limitations in the data collected

### Class Non-Predictive Factors

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$homophylyList[[3]][[2]] > 0)) {
  cat(fileList[[1]]$homophylyList[[3]][[2]])
} else {
  cat("None")
}
```
</center>

>These factors do not statistically significantly influence the nature and
function of the class
  

  
Row {data-width=250}
-----------------------------------------------------------------------

### Class Diameter {data-height=150} 

```{r}
diameter <- fileList[[1]]$totalNetworkInfo[[3]][[4]]
nodes <- length(fileList[[1]]$totalNetworkInfo[[3]][[10]])

# derive sector colours for gauge from nrow(nodes) and whether
# the graph is fragmented

if(graphConnected(fileList[[1]]$SSNQGraph[[3]])== F) {
  customSectors <-  gaugeSectors (
    danger = c(0, 100)
  )
} else {
  customSectors <-  gaugeSectors (
    success = c(0,(nodes/6)),
    warning = c((nodes/6), (nodes/3)),
    danger = c((nodes/3), (nodes/2)))
}

#make gauge
gauge(round(diameter, digits = 2), min = 1, max = (nodes/2), sectors = customSectors)

#provide warning text if graph is fragmented.
if (graphConnected(fileList[[1]]$SSNQGraph[[3]]) == F) {
  SSNQConnectedWarning <- paste("However, as this group is split across ",
    "separate unconnected sub-groups, this may not be a good measure of group ",
    "cohesiveness.",
    sep = "")
} else {
  SSNQConnectedWarning <- ""
}
```
 
> The most distant people are `r round(diameter, digits=0)` relationships away
from each other. <span style="color: red;">`r SSNQConnectedWarning`</span> 

### Percentage of Positive Relationships {data-height=150} 

```{r}
edgeDensity <- fileList[[1]]$totalNetworkInfo[[3]][[5]]
edgeDensityPercentage <- round((edgeDensity*100), digits = 0)
gauge(edgeDensityPercentage, min = 0, max = 100, symbol = '%', gaugeSectors(
    success = c(21, 100), 
    warning = c(16, 20), 
    danger = c(0, 15)
  ))
```
  
> `r round(edgeDensity, digits = 2)*100`% of all possible relationships are
strongly positive.
  
### Class Reciprocity {data-height=150} 
  
```{r}
reciprocity <- fileList[[1]]$totalNetworkInfo[[3]][[6]]
reciprocityPercentage <- round((reciprocity*100), digits = 0)
gauge(reciprocityPercentage, min = 0, max = 100, symbol = '%', gaugeSectors(
    success = c(55, 100), 
    warning = c(40, 54), 
    danger = c(0, 39)
  ))
```

> Both parties agreed on a relationship status
`r round(reciprocity, digits = 2)*100`% of the time.

### Class Communities Dendrogram  {data-height=550} 
<center>
```{r}

fileList[[1]]$dendrogramList[[3]]

```
</center>

> This shows how the relational landscape divides into subgroups, mirrored in the colour of the dots on the summary graph.  The higher the number on the left, the bigger the distance between the group members attached at the split.


Network Maps 
----------------------------------------------------------------

### Summary graph {.no-padding data-height=700} 

```{r}

JSData3 <- jsonlite::read_json("D3JSData31.json")

repeatedforcedirectedOutput("repeatedforcedirected3")
output$repeatedforcedirected3 <- renderRepeatedforcedirected(repeatedforcedirected("Hello", JSData3))

```

> The lines on this graph represent the strongest relationships in the class. Each dot is a person, and each line is a strong relationship. The colours indicate cliques, or subgroups in the data which naturally form as people form and maintain social networks. Zoom using the scroll wheel or pinch on a touchscreen device, and drag people around to see who is connected most closely to them. The position on the graph doesn't matter itself, its about the position relative to the other people and how linked in they are with the group as a whole.


Key Network Information {data-width=250}
-----------------------------------------------------

### Class 'Hubs' {data-height=350} 

<center>
```{r, results = 'asis'}
if (length(fileList[[1]]$HSList[[3]]) > 0) {
  cat(fileList[[1]]$HSList[[3]])
} else {
  cat("Contact Volume Hub Analysis Encountered an Error")
}
```
</center>

> These people are the lifeblood of the class: Their absence would hamper communication and they make good contacts for new members to get more integrated.  They are those who report the most highly positive relationships with others.

### Class 'Authorities' {data-height=350} 

<center>
```{r, results = 'asis'}
if (length(as.character(fileList[[1]]$ASList[[3]]) > 0)) {
  cat(fileList[[1]]$ASList[[3]])
} else {
  cat("Network Authority Analysis Encountered an Error")
}
```
</center>

>These tend to be the class members who are  looked up to, or approached for advice or information by their peers: They have high value to others in the group.  They are those whom others identify as having the most highly positive relationships with.

### Fundamental Relationships  {data-height=750}

<center>
```{r, results = 'asis'}
cat(paste(fileList[[1]]$totalNetworkInfo[[3]][[9]][1,1], "<br>", "and<br>",
          fileList[[1]]$totalNetworkInfo[[3]][[9]][1,2])
    )
```

***

```{r, results = 'asis'}
cat(paste(fileList[[1]]$totalNetworkInfo[[3]][[9]][2,1], "<br>", "and<br>",
          fileList[[1]]$totalNetworkInfo[[3]][[9]][2,2])
    )
```

***

```{r, results = 'asis'}
cat(paste(fileList[[1]]$totalNetworkInfo[[3]][[9]][3,1], "<br>", "and<br>",
          fileList[[1]]$totalNetworkInfo[[3]][[9]][3,2])
    )
```
</center>

>These are the relationships which make the class operate as it does.  Promoting
these adds cohesion.

### Network Isolates

<center>
```{r, results = 'asis'}
if(!is.null(fileList[[1]]$isolatesList[[3]])) {
  cat(fileList[[1]]$isolatesList[[3]])
}
```
</center>

>These people are not joined to any others in the network by positive
relationships in at least one of the dimensions they were asked about.



Student - Student Individual Score Profiles {data-navmenu="Class Name"}
=======================================================================

Individual Score Profiles {data-width=900 .tabset}
-----------------------------------------------------------------------

### Interaction Positivity

```{r}
renderPlotly ({
  fileList[[1]]$polarGraphList[[1]]
})
```

> Scores for each person for how well they report knowing one another can be explored here.  Click on the person's name in the list to visualise the scores and hover over the graph for more details.  Select multiple people to overlay their scores for comparison.  The green dotted line is the average score given by the network.


### Knowing One Another

```{r}
renderPlotly ({
  fileList[[1]]$polarGraphList[[2]]
})
```

> Scores for each person for how well they report knowing one another can be explored here.  Click on the person's name in the list to visualise the scores and hover over the graph for more details.  Select multiple people to overlay their scores for comparison.  The green dotted line is the average score given by the network.


### Student Value and Respect

```{r}
renderPlotly ({
  fileList[[1]]$polarGraphList[[3]]
})
```

> Scores for each person for how well they report knowing one another can be explored here.  Click on the person's name in the list to visualise the scores and hover over the graph for more details.  Select multiple people to overlay their scores for comparison.  The green dotted line is the average score given by the network.


Degree {.tabset}
-----------------------------------------------------------------------

### Interaction Positivity

#### 'Interaction Positivity' Degree All Scores

```{r}
renderPlotly ({
  fileList[[1]]$degreeAllHistogramList[[1]]
})
```

> The higher the overall degree score, the more tied in the person is to the class.  Those learners who score nearest the average are those who are best placed to develop resiliency in the relational network of the class when they are encouraged to relate to one another, because they have connections to bring to bear, and have relational overhead to be able to develop further relationships without others suffering from divided attention.

#### 'Interaction Positivity' Degree In Scores

```{r}
renderPlotly ({
  fileList[[1]]$degreeInHistogramList[[1]]
})
```

> A higher 'Degree in' score indicates that more people in the class come
to this person for information

#### 'Interaction Positivity' Degree Out Scores

```{r}
renderPlotly({
  fileList[[1]]$degreeOutHistogramList[[1]]
})
```

> A higher 'Degree out' score indicates that the person is well connected within the class.

### Knowing One Another

#### 'Knowing One Another' Degree All Scores

```{r}
renderPlotly ({
  fileList[[1]]$degreeAllHistogramList[[2]]
})
```

> The higher the overall degree score, the more tied in the person is to the class.  Those learners who score nearest the average are those who are best placed to develop resiliency in the relational network of the class when they are encouraged to relate to one another, because they have connections to bring to bear, and have relational overhead to be able to develop further relationships without others suffering from divided attention.

#### 'Knowing One Another' Degree In Scores

```{r}
renderPlotly ({
  fileList[[1]]$degreeInHistogramList[[2]]
})
```

> A higher 'Degree in' score indicates that more people in the class come
to this person for information

#### 'Knowing One Another' Degree Out Scores

```{r}
renderPlotly({
  fileList[[1]]$degreeOutHistogramList[[2]]
})
```

> A higher 'Degree out' score indicates that the person is well connected within the class.

### Student Value and Respect

#### 'Value and Respect' Degree All Scores

```{r}
renderPlotly ({
  fileList[[1]]$degreeAllHistogramList[[3]]
})
```

> The higher the overall degree score, the more tied in the person is to the class.  Those learners who score nearest the average are those who are best placed to develop resiliency in the relational network of the class when they are encouraged to relate to one another, because they have connections to bring to bear, and have relational overhead to be able to develop further relationships without others suffering from divided attention.

#### 'Value and Respect' Degree In Scores

```{r}
renderPlotly ({
  fileList[[1]]$degreeInHistogramList[[3]]
})
```

> A higher 'Degree in' score indicates that more people in the class come
to this person for information

#### 'Value and Respect' Degree Out Scores

```{r}
renderPlotly({
  fileList[[1]]$degreeOutHistogramList[[3]]
})
```

> A higher 'Degree out' score indicates that the person is well connected within the class

Raw Data {data-navmenu="Class Name"}
=======================================================================

Below is the raw data from which the Relationships Foundation have derived their
analysis. These data are not anonymised and should be treated sensitively.

Student-Student {.tabset}
-----------------------------------------------------------------------

### Student Characteristic Information

```{r}
create_dt(fileList[[1]]$nodes)
```

### Student - Student Interaction Positivity

```{r}
create_dt(fileList[[1]]$rawEdgesList[[1]])
```

### Student - Student Knowing One Another

```{r}
create_dt(fileList[[1]]$rawEdgesList[[2]])
```

### Student - Student Value and Respect

```{r}
create_dt(fileList[[1]]$rawEdgesList[[3]])
```


Belongingness Measure {data-navmenu="Class Name"}
==================================================================

row {.sidebar}
-------------------------------------------------------------------

```{r}
lowBelongingnessNumber <- table(unprocessedBelongingnessData$`Belongingness Stratified`)[["Low"]]
highBelongingnessNumber <- table(unprocessedBelongingnessData$`Belongingness Stratified`)[["High"]]
causeForConcernRowIndex <- which(unprocessedBelongingnessData$`Belongingness Stratified` == "Low")
causeForConcernNames <- vector()
for (i in 1:length(causeForConcernRowIndex)) {
  causeForConcernNames[i] <- unprocessedBelongingnessData[causeForConcernRowIndex[i],"id"]
}

if(lowBelongingnessNumber == 1) {
  lowBelongingnessText <- paste(lowBelongingnessNumber, "member", sep = " ")
} else {
  lowBelongingnessText <- paste(lowBelongingnessNumber, "members", sep = " ")  
}

if(highBelongingnessNumber == 1) {
  highBelongingnessText <- paste(highBelongingnessNumber, "member", sep = " ")
} else {
  highBelongingnessText <- paste(highBelongingnessNumber, "members", sep = " ")  
}


if(highBelongingnessNumber > (lowBelongingnessNumber*2)) {
  belongingnessNumberCommentary <- "This meets or exceeds the international average result for a group of learners"
} else if (highBelongingnessNumber > lowBelongingnessNumber) {
  belongingnessNumberCommentary <- "This is not cause for concern per se, but is a little lower than the international average result for a group of learners"
} else if (highBelongingnessNumber < lowBelongingnessNumber) {
  belongingnessNumberCommentary <- "This is significantly lower than the international average result for a group of learners and may well represent a reasonable cause for concern"
} else {
  belongingnessNumberCommentary <- ""
}
```

The data for the Belongingness survey of class `r fileList[[1]]$className` at `r clientName` is presented on this dashboard page.

This class contains `r highBelongingnessText` with high belongingness scores and `r lowBelongingnessText` with low ones.
`r belongingnessNumberCommentary`

#### Class Members with Notably Low Belongingness:

```{r results='asis'}
if(!length(causeForConcernNames)==0) {
  for (i in causeForConcernNames){
    cat("*", i, "\n")
  }
} else {
  cat("None")
}
```

The data table to the right allows for filtering of the data by typing in the boxes 
above each column.  The axes of the graph can be set using the drop down boxes 
below.

```{r}
selectInput(inputId = "GB",
            label = "Group By (x axis)",
            choices = GBChoices,
            selected = "id")
```

```{r}
selectInput(inputId = "OB",
            label = "Order By (x axis)",
            choices = c("Ascending",
                        "Descending",
                        "Alphabetical"),
            selected = "Alphabetical")
```

```{r}
selectInput(inputId = "Metric",
            label = "Metric (y axis)",
            choices = metricChoices,
            selected = "Belongingness Mean")
```


```{r}
significantFactorsFound <- "We have performed analysis on the data to identify
where there are statistically significant differences in the data that are due
to more than chance across each of the metrics the data contain.  Where these
have been found to be significant, they are viewable using the 'Snapshot' box
below:"

significantFactorsNotFound <- "We have performed analysis on the data to
determine if any differences between groups are down to expected variance or if
they are statistically significant, and for each of the factors in this dataset
there are no indications that significant differences exist."

```

`r if(!length(significantPredictors) == 0) {significantFactorsFound} else {significantFactorsNotFound}`


```{r}
#for each significant factor, view it using a dropdown list initialised by an
#action button

#make a list of SDVs that show significant links for each experimental variable.
SDVSet <- list()
for (i in 1:ncol(SDVTable)) {
  SDVSet[[i]] <- as.vector(SDVTable[,i])
  SDVSet[[i]] <- SDVSet[[i]][!is.na(SDVSet[[i]])]
}
SDVSetNames <- colnames(SDVTable)
names(SDVSet) <- SDVSetNames

selectInput(inputId = "experimentalVariable",label = "Choose a Snapshot to View", choices = colnames(valueTable), selected = 1) 
actionButton(
    "init", "View Snapshot", 
    onclick = "var $btn=$(this); setTimeout(function(){$btn.remove();},0);"
  )
uiOutput("ui")

makeSnapshot <- eventReactive(input$init, {
  observe({
    x <- input$experimentalVariable

    updateSelectInput(session, "GB",
                      label = "Group By (x axis)",
                      choices = GBChoices,
                      selected = valueTable[2, ..x]
                      )

    updateSelectInput(session, "Metric",
                      label = "Metric(y axis)",
                      choices = metricChoices,
                      selected = valueTable[3, ..x]
                      )
  })
})

#make the new button on submit button being pressed:
observeEvent(input$init, {
  makeSnapshot()
})

```

```{r}
interactionEffectsFound <- "In addition to these effects, we have determined
that there are interaction effects between some of the factors we studied.
Interaction effects are when the combination of the factors have a greater
impact on the difference in result than either one alone can fully explain.
The interaction effects we found are:"

interactionEffectsNotFound <- "In addition for looking to identify significant
effects for each factor alone, we also explored the data for cases where the
combination of factors could explain any difference in result better than
individual factors.  In this case there were none."
```

`r if(!length(interactionEffects) == 0) { interactionEffectsFound } else if (!length(significantPredictors) == 0 && length(interactionEffects == 0)) { interactionEffectsNotFound }`

```{r, results='asis'}
#insert list of interaction effects if relevant
if(!length(interactionEffects)==0) {
  bullets <- as.list(unique(names(interactionEffects)))
  for (i in bullets){
    cat("*", i, "\n")
  }
}
```


column
-------------------------------------------------------------------

### {-}

```{r}
  DTOutput("WBNumeric")
```

column
-------------------------------------------------------------------

### {-}

```{r}
      output$plotBelongingness2 <- renderPlot({
        updateData <- 
          WBNumeric %>%
          group_by(!!! rlang::syms(input$GB)) %>%
          summarise_if(is.numeric,mean,na.rm=T)
        
        xvar <- rlang::sym(input$GB)
        yvar <- rlang::sym(input$Metric)
        aesthetic <- if (input$OB == "Ascending") {
          aes(x = reorder(factor(!! xvar, levels = unique(!! xvar)), !! yvar, ordered = F),
                   y = !! yvar,
                   fill=!! xvar)
        } else if (input$OB == "Descending") {
          aes(x = reorder(factor(!! xvar, levels = unique(!! xvar)), -!! yvar, ordered = F),
                   y = !! yvar,
                   fill=!! xvar)
        } else {
          aes(x = factor(!! xvar, levels = unique(!! xvar)),
                   y = !! yvar,
                   fill=!! xvar)
        }
        ggplot(updateData[input$WBNumeric_rows_all,],
               aesthetic) +
        ggtitle(paste(clientName, fileList[[1]]$className, "Belongingness Scoring Histogram", sep = "
")) +
        scale_colour_brewer(palette="Accent") +
        theme_bw() +
        theme(rect = element_rect(fill = "transparent", colour = NA),
              plot.title = element_text(hjust = 0.5, size = 15, face = "bold"),
              axis.line = element_line(size=1, colour = "grey"),
              panel.grid.major = element_line(colour = "#d3d3d3"),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_rect(fill = "transparent", colour = NA),
              plot.background = element_rect (fill = "transparent", colour = NA),
              axis.text.x=element_text(colour="black", size = belongingnessFontSize, angle = -45),
              axis.text.y=element_text(colour="black", size = belongingnessFontSize),
              axis.title.x = element_text(colour = "black"),
              axis.title.y = element_text(colour = "black"),
              legend.key=element_rect(fill = "transparent", colour = NA),
              legend.background = element_rect(fill = "transparent"),
              legend.box.background = element_rect(fill = "transparent")
              ) +
          labs(x = input$GB) +
        geom_col()
     })

      output$WBNumeric <- DT::renderDT(WBNumeric, 
                                       caption = "Table for Subsetting Belongingness Data", 
                                       fillContainer = TRUE,
                                       filter = list(autowidth = TRUE,
                                                     position = "top",
                                                     clear = FALSE),
                                       class="cell-border stripe",
                                       rownames = FALSE,
                                       selection = 'none',
                                       options = list(
                         scrollY="36vh",scrollX="300px",
                         pageLength = 50,
                         autoWidth = TRUE, columnDefs =
                         list(list(width = '100', targets = "_all", visible = TRUE))))
                                      
  plotOutput("plotBelongingness2")
```


      