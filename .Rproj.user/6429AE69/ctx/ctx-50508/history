setwd("~/IBSCMasterFeedbackDash")
source("packageSetup.R")
#Pull in config info
source("surveyConfig.R")
source("clientConfig.R")
#import student data
nodes <- read.xlsx(file, sheet = 1)
#import student data
data <- dataFile
nodes <- read.xlsx(file, sheet = 1)
source("~/IBSCMasterFeedbackDash/clientConfig.R")
#import student data
data <- dataFile
#import student data
file <- dataFile
nodes <- read.xlsx(file, sheet = 1)
edges1 <- read.xlsx(file, sheet = 2)
edges2 <- read.xlsx(file, sheet = 3)
edges3 <- read.xlsx(file, sheet = 4)
#extract class name from file
className <- substring(file, regexpr("Student", file) + 8)
className <- substring(className, 1, nchar(className)-5) #remove ".xlsx"
#set random seed from config file
set.seed (seed)
source("assets/R/makeResponseNumeric.R")
nodesKeyBelongingnessPositive <- keyToNumeric(scoreData = nodes[,responseColumnsBelongingness],
answers = nodeAnswersBelongingness,
normalized = FALSE)
nodesKeyBelongingnessNegative <- nodesKeyBelongingnessPositive
for (i in 1:length(nodesKeyBelongingnessNegative$newAnswers)) {
nodesKeyBelongingnessNegative$newAnswers[i] <- 3 - nodesKeyBelongingnessNegative$newAnswers[i]
}
nodesKeyBelongingnessCategorical <- data.frame(nodeAnswersBelongingness)
nodesKeyBelongingnessCategorical$newAnswers <- c("High", "Moderate", "Moderate", "Low")
nodesKeyStudentTeacher <- keyToNumeric(scoreData = nodes[,responseColumnsStudentTeacher],
answers = nodeAnswersStudentTeacher,
normalized = FALSE)
nodesKeyStudentTeacherCategorical <- data.frame(nodeAnswersStudentTeacher)
nodesKeyStudentTeacherCategorical$newAnswers <- c("High", "High", "Moderate", "Moderate", "Low", "Low")
names(nodesKeyStudentTeacherCategorical) <- c("answers", "newAnswers")
#loop over each relevant column for additional measures such as belongingness and student-teacher questions and bind a numeric column to nodes
#get column numbers
studentTeacherRegExQuestionText <- c(
"I\\.can\\.talk\\.to\\.or\\.contact\\.my\\.",
"It\\.is\\.worth\\.building\\.a\\.good\\.relationship\\.with\\.my\\.",
"\\.and\\.I\\.have\\.shared\\.goals\\.for\\.my\\.progress\\.and\\.development",
"cares\\.about\\.me",
"has\\.a\\.good\\.understanding\\.of\\.my\\.skills\\.and\\.interests",
"inspires\\.and\\.motivates\\.me",
"recognises\\.and\\.rewards\\.my\\.efforts"
)
studentTeacherResponseColumnIndices <- vector()
for(i in 1:length(studentTeacherRegExQuestionText)) {
studentTeacherResponseColumnIndices[[length(studentTeacherResponseColumnIndices)+1]] <- grep(studentTeacherRegExQuestionText[i], colnames(nodes))
}
if(length(studentTeacherResponseColumnIndices)>7) {
warning("more student - teacher questions have been matched than there should be.  Consider checking the studentTeacherRegExQuestionText for unwanted matches")
}
belongingnessRegExQuestionTextPositive <- c(
"I\\.feel\\.like\\.I\\.belong\\.at",
"I\\.make\\.friends\\.easily\\.at",
"\\.seem\\.to\\.like\\.me"
)
belongingnessRegExQuestionTextNegative <- c(
"I\\.feel\\.awkward\\.and\\.out\\.of\\.place",
"I\\.feel\\.like\\.an\\.outsider",
"I\\.feel\\.lonely\\.at"
)
belongingnessResponseColumnIndicesPositive <- vector()
for(i in 1:length(belongingnessRegExQuestionTextPositive)) {
belongingnessResponseColumnIndicesPositive[[length(belongingnessResponseColumnIndicesPositive)+1]] <- grep(belongingnessRegExQuestionTextPositive[i], colnames(nodes))
}
if(length(belongingnessResponseColumnIndicesPositive)>3) {
warning("more belongingness questions have been matched than there should be.  Consider checking the belongingnessRegExQuestionTextPositive for unwanted matches")
}
belongingnessResponseColumnIndicesNegative <- vector()
for(i in 1:length(belongingnessRegExQuestionTextNegative)) {
belongingnessResponseColumnIndicesNegative[[length(belongingnessResponseColumnIndicesNegative)+1]] <- grep(belongingnessRegExQuestionTextNegative[i], colnames(nodes))
}
if(length(belongingnessResponseColumnIndicesNegative)>3) {
warning("more belongingness questions have been matched than there should be.  Consider checking the belongingnessRegExQuestionTextNegative for unwanted matches")
}
#make numeric columns for belongingness positive questions (0-3)
for(i in 1:length(nodes[,belongingnessResponseColumnIndicesPositive])) {
numericReplacementVectorPositive <- makeResponseNumeric(
data = nodes[,belongingnessResponseColumnIndicesPositive[i]],
conversionKey = nodesKeyBelongingnessPositive)
numericReplacementColumnPositive <- data.frame(numericReplacementVectorPositive)
getNames <- names(nodes)
names(numericReplacementColumnPositive) <- paste0(
getNames[[belongingnessResponseColumnIndicesPositive[[i]]]], ".numeric")
nodes <- cbind(nodes, numericReplacementColumnPositive)
}
#make numeric columns for belongingness negative questions (3-0)
for(i in 1:length(nodes[,belongingnessResponseColumnIndicesNegative])) {
numericReplacementVectorNegative <- makeResponseNumeric(
data = nodes[,belongingnessResponseColumnIndicesNegative[i]],
conversionKey = nodesKeyBelongingnessNegative)
numericReplacementColumnNegative <- data.frame(numericReplacementVectorNegative)
getNames <- names(nodes)
names(numericReplacementColumnNegative) <- paste0(
getNames[[belongingnessResponseColumnIndicesNegative[[i]]]], ".numeric")
nodes <- cbind(nodes, numericReplacementColumnNegative)
}
belongingnessResponseColumnIndices <- c(
belongingnessResponseColumnIndicesPositive,
belongingnessResponseColumnIndicesNegative)
belongingnessResponseColumnIndices <- sort(belongingnessResponseColumnIndices)
#make stratified columns for belongingness (low, medium, high)
modifiedNodes <- nodes[,belongingnessResponseColumnIndices]
originalNames <- names(modifiedNodes)
names(modifiedNodes) <- c("a", "b", "c", "d", "e", "f")
replacementNames <- names(modifiedNodes)
modifiedNodes <- modifiedNodes %>%
left_join(nodesKeyBelongingnessCategorical, by = c("a" = "nodeAnswersBelongingness"))
names(modifiedNodes)[names(modifiedNodes) == 'newAnswers'] <-  paste(originalNames[1], "(stratified)", sep = ".")
modifiedNodes <- modifiedNodes %>%
left_join(nodesKeyBelongingnessCategorical, by = c("b" = "nodeAnswersBelongingness"))
names(modifiedNodes)[names(modifiedNodes) == 'newAnswers'] <-  paste(originalNames[2], "(stratified)", sep = ".")
modifiedNodes <- modifiedNodes %>%
left_join(nodesKeyBelongingnessCategorical, by = c("c" = "nodeAnswersBelongingness"))
names(modifiedNodes)[names(modifiedNodes) == 'newAnswers'] <-  paste(originalNames[3], "(stratified)", sep = ".")
modifiedNodes <- modifiedNodes %>%
left_join(nodesKeyBelongingnessCategorical, by = c("d" = "nodeAnswersBelongingness"))
names(modifiedNodes)[names(modifiedNodes) == 'newAnswers'] <-  paste(originalNames[4], "(stratified)", sep = ".")
modifiedNodes <- modifiedNodes %>%
left_join(nodesKeyBelongingnessCategorical, by = c("e" = "nodeAnswersBelongingness"))
names(modifiedNodes)[names(modifiedNodes) == 'newAnswers'] <-  paste(originalNames[5], "(stratified)", sep = ".")
modifiedNodes <- modifiedNodes %>%
left_join(nodesKeyBelongingnessCategorical, by = c("f" = "nodeAnswersBelongingness"))
names(modifiedNodes)[names(modifiedNodes) == 'newAnswers'] <-  paste(originalNames[6], "(stratified)", sep = ".")
modifiedNodes <- modifiedNodes[,7:ncol(modifiedNodes)]
nodes <- cbind(nodes, modifiedNodes)
#make numeric columns for student/teacher questions (0-5)
for(i in 1:length(nodes[,studentTeacherResponseColumnIndices])) {
numericReplacementVector <- makeResponseNumeric(
data = nodes[,studentTeacherResponseColumnIndices[i]],
conversionKey = nodesKeyStudentTeacher)
numericReplacementColumn <- data.frame(numericReplacementVector)
getNames <- names(nodes)
names(numericReplacementColumn) <- paste0(
getNames[[studentTeacherResponseColumnIndices[[i]]]], ".numeric")
nodes <- cbind(nodes, numericReplacementColumn)
}
#make stratified columns for student - teacher questions (low, medium, high)
modifiedNodesST <- nodes[,studentTeacherResponseColumnIndices]
originalNamesST <- names(modifiedNodesST)
names(modifiedNodesST) <- c("a", "b", "c", "d", "e", "f", "g")
replacementNames <- names(modifiedNodesST)
modifiedNodesST <- modifiedNodesST %>%
left_join(nodesKeyStudentTeacherCategorical, by = c("a" = "answers"))
names(modifiedNodesST)[names(modifiedNodesST) == 'newAnswers'] <-  paste(originalNamesST[1], "(stratified)", sep = ".")
modifiedNodesST <- modifiedNodesST %>%
left_join(nodesKeyStudentTeacherCategorical, by = c("b" = "answers"))
names(modifiedNodesST)[names(modifiedNodesST) == 'newAnswers'] <-  paste(originalNamesST[2], "(stratified)", sep = ".")
modifiedNodesST <- modifiedNodesST %>%
left_join(nodesKeyStudentTeacherCategorical, by = c("c" = "answers"))
names(modifiedNodesST)[names(modifiedNodesST) == 'newAnswers'] <-  paste(originalNamesST[3], "(stratified)", sep = ".")
modifiedNodesST <- modifiedNodesST %>%
left_join(nodesKeyStudentTeacherCategorical, by = c("d" = "answers"))
names(modifiedNodesST)[names(modifiedNodesST) == 'newAnswers'] <-  paste(originalNamesST[4], "(stratified)", sep = ".")
modifiedNodesST <- modifiedNodesST %>%
left_join(nodesKeyStudentTeacherCategorical, by = c("e" = "answers"))
names(modifiedNodesST)[names(modifiedNodesST) == 'newAnswers'] <-  paste(originalNamesST[5], "(stratified)", sep = ".")
modifiedNodesST <- modifiedNodesST %>%
left_join(nodesKeyStudentTeacherCategorical, by = c("f" = "answers"))
names(modifiedNodesST)[names(modifiedNodesST) == 'newAnswers'] <-  paste(originalNamesST[6], "(stratified)", sep = ".")
modifiedNodesST <- modifiedNodesST %>%
left_join(nodesKeyStudentTeacherCategorical, by = c("g" = "answers"))
names(modifiedNodesST)[names(modifiedNodesST) == 'newAnswers'] <-  paste(originalNamesST[7], "(stratified)", sep = ".")
modifiedNodesST <- modifiedNodesST[,8:ncol(modifiedNodesST)]
nodes <- cbind(nodes, modifiedNodesST)
#make the numeric keypair dataframes from which to convert
#relationship question answers
edgesKey <- keyToNumeric(scoreData = edges[,xxxxxxxxx],
answers = edgeAnswers,
normalized = TRUE)
#for each network question, bind a numeric column to edges data frames with
#numeric answers in, called 'Network'
numericReplacementVector <- makeResponseNumeric(data = edges1$Q2,
conversionKey = edgesKey)
numericReplacementColumn <- data.frame(numericReplacementVector)
names(numericReplacementColumn) <- "Network"
edges1 <- cbind(edges1, numericReplacementColumn)
numericReplacementVector <- makeResponseNumeric(data = edges2$Q3,
conversionKey = edgesKey)
numericReplacementColumn <- data.frame(numericReplacementVector)
names(numericReplacementColumn) <- "Network"
edges2 <- cbind(edges2, numericReplacementColumn)
numericReplacementVector <- makeResponseNumeric(data = edges3$Q4,
conversionKey = edgesKey)
numericReplacementColumn <- data.frame(numericReplacementVector)
names(numericReplacementColumn) <- "Network"
edges3 <- cbind(edges3, numericReplacementColumn)
#List network question data to enable looping over it
surveyData <- list(edges1, edges2, edges3)
#save a list containing the raw data for passing raw to the dash
rawEdgesList <- surveyData
#Filter edges of each network question for most positive only
surveyDataFiltered <- list()
for(i in 1:length(surveyData)) {
surveyDataFiltered[[i]] <- dplyr::filter(surveyData[[i]],
surveyData[[i]]$Network >
thresholdForEdgeDrawing)
}
#perform summative network analysis on each relationship question
source("networkSurveyAnalysis.R")
totalNetworkInfo <- list()
for(i in 1:length(surveyDataFiltered)) {
totalNetworkInfo[[length(totalNetworkInfo)+1]] <-
surveyDataAnalysis(questionData = surveyDataFiltered[[i]])
}
#Insert HTML into a list to display it properly in-dash
formatDataForDisplay <- function(Data) {
Data <- na.omit(Data)
ogValue <- Data[length(Data)]
formattedValue <- paste(Data, "<br>", sep=" ")
formattedValue[length(formattedValue)] <- ogValue
return(formattedValue)
}
#find isolates
isolatesList <- list()
for(i in 1:length(totalNetworkInfo)) {
isolatesList[[i]] <- nodes$Name [!(nodes$Name %in%
totalNetworkInfo[[i]][[3]][["People"]])]
isolatesList[[i]][isolatesList[[i]] == ""] <- NA
}
#format isolates list for display in dash, or display 'None'
for(i in 1:length(isolatesList)) {
if(length(isolatesList[[i]])>0) {
isolatesList[[i]] <- formatDataForDisplay(isolatesList[[i]])
} else {
isolatesList[[i]] <- "None"
}
}
#Prepare data for D3.JS forceDirected
SSNQGraphList <- list()
SSNQCommunitiesDataList <- list()
SSNQMembersList <- list()
Graph2 <- list()
for (i in 1:length(surveyDataFiltered)) {
SSNQGraphFromDataset <- data.frame(
surveyDataFiltered[[i]]$Source,
surveyDataFiltered[[i]]$Target,
... = surveyDataFiltered[[i]]$Network)
#Make an igraph object for each question for the D3 R port.
Graph2[[i]] <- SSNQGraphFromDataset
SSNQGraphList[[i]] <- graph_from_data_frame(SSNQGraphFromDataset,
directed = T)
# Perform Communities Analysis for each igraph object
SSNQCommunitiesDataList[[i]] <- cluster_walktrap(SSNQGraphList[[i]])
SSNQMembersList[[i]] <- membership(SSNQCommunitiesDataList[[i]])
}
#Convert igraph to D3
SSNQNetworkD3 <- list()
for(i in 1:length(SSNQGraphList)) {
SSNQNetworkD3[[i]] <- igraph_to_networkD3(SSNQGraphList[[i]],
group = SSNQMembersList[[i]])
}
#Set up the edge data for porting to D3.JS
edgeDataSetup <- function(SSNQGraph) {
#Find every co-occuring join and assign each 2, while the others are assigned 1
x <- SSNQGraph
colnamesx <- colnames(x)
for(l in 1:length(colnamesx)) {
if(colnamesx[[l]] == "...") {
colnamesx[[l]] <- "scoreStrength"
}
}
colnames(x) <- colnamesx
#find the second instance of each duplication and assign it TRUE
duplicates <- duplicated(t(apply(x[,1:2], 1, sort)))
x <- cbind(x, duplicates = duplicates)
#split between true and false and search for the mutual partners in z, then use
# these to change x
y <- filter(as_tibble(x), duplicates == TRUE)
z <- filter(as_tibble(x), duplicates == FALSE)
y <- y[,c(2,1,3,4)]
colnames(y) <- colnames(x)
a <- inner_join(z[,1:2],y[,1:2])
x <- as_tibble(x)
for (k in 1:nrow(a)) {
for (j in 1:nrow(x)) {
if (identical(x[j,1:2], a[k,1:2])) {
x[j,4] <- TRUE
x[j,3] <- x[j,3]+1
}
}
}
#reorder x to suit D3.JS port formatting of source, target, mutual, score
x <- x[,c(1,2,4,3)]
colnames(x) <- c("source", "target", "mutual", "score")
cols <- sapply(x, is.logical)
x[,cols] <- lapply(x[,cols], as.numeric)
for(m in 1:nrow(x[,3])) {
x[m,3] <- x[m,3]+1
}
#reassign x to the original variable
return(x)
}
edgeDataList <- list()
thing <- SSNQGraphList[[1]]
edgeDataList[[1]] <- edgeDataSetup(Graph2[[1]])
edgeDataList[[2]] <- edgeDataSetup(Graph2[[2]])
edgeDataList[[3]] <- edgeDataSetup(Graph2[[3]])
#attempt to build overall network from unfiltered data
overallEdgeList <- list()
for(i in 1:length(rawEdgesList)){
overallEdgeList[[i]] <- rawEdgesList[[i]][c("Source", "Target", "Network")]
}
overallEdgesList <- do.call("rbind", overallEdgeList)
overallEdgesList$Score <- rep(1, nrow(overallEdgesList))
# Reorder values in first 2 cols and cbind with df[,3]
m <- cbind(t(apply(overallEdgesList[1:2], 1, sort)), overallEdgesList[,3])
# Sum third column grouped by first and second column
aggregate(as.numeric(m[,3]), by = list(m[,1],m[,2]),FUN=sum)
overallEdgesList<- m
# Sum third column grouped by first and second column
overallSSEdgesList <- aggregate(as.numeric(m[,3]), by = list(m[,1],m[,2]),FUN=sum)
overallSSEdgesList
overallSSEdgesList <- edgeDataSetup(overallSSEdgesList)
overallSSEdgesList
print(overallSSEdgesList(n=100))
View(overallSSEdgesList)
# Sum third column grouped by first and second column
overallSSEdgesDF <- aggregate(as.numeric(m[,3]), by = list(m[,1],m[,2]),FUN=sum)
overallSSEdgesDF <- edgeDataSetup(overallSSEdgesDF)
for(i in 1:nrow(overallSSEdgesDF)) {
if(overallSSEdgesDF[i,"score"]>3){
overallSSEdgesDF[i,"mutual"]<- 2
}
overallSSEdgesDF[i,"mutual"]
}
View(overallSSEdgesDF)
overallEdgesList <- do.call("rbind", overallEdgeList)
overallEdgesList$Score <- rep(1, nrow(overallEdgesList))
#filter entries under a given score threshold 0.5
overallEdgesList <- filter(overallEdgesList, score < 0.5)
names(overallEdgesList)
#filter entries under a given score threshold 0.5
overallEdgesList <- filter(overallEdgesList, Score < 0.5)
# Reorder values in first 2 cols and cbind with df[,3]
m <- cbind(t(apply(overallEdgesList[1:2], 1, sort)), overallEdgesList[,3])
# Sum third column grouped by first and second column
overallSSEdgesDF <- aggregate(as.numeric(m[,3]), by = list(m[,1],m[,2]),FUN=sum)
names(m)
overallEdgesList <- do.call("rbind", overallEdgeList)
overallEdgesList$Score <- rep(1, nrow(overallEdgesList))
#filter entries under a given score threshold 0.5
overallEdgesList <- filter(overallEdgesList, Score < 0.5)
# Reorder values in first 2 cols and cbind with df[,3]
m <- cbind(t(apply(overallEdgesList[1:2], 1, sort)), overallEdgesList[,3])
m
overallEdgesList
overallEdgesList <- do.call("rbind", overallEdgeList)
overallEdgesList$Score <- rep(1, nrow(overallEdgesList))
overallEdgesList
#filter entries under a given score threshold 0.5
overallEdgesList <- filter(overallEdgesList, Network < 0.5)
#filter entries under a given score threshold 0.5
overallEdgesList
overallEdgesList <- do.call("rbind", overallEdgeList)
overallEdgesList$Score <- rep(1, nrow(overallEdgesList))
#filter entries under a given score threshold 0.5
overallEdgesList <- filter(overallEdgesList, Network > 0.5)
#filter entries under a given score threshold 0.5
overallEdgesList
# Reorder values in first 2 cols and cbind with df[,3]
m <- cbind(t(apply(overallEdgesList[1:2], 1, sort)), overallEdgesList[,3])
# Sum third column grouped by first and second column
overallSSEdgesDF <- aggregate(as.numeric(m[,3]), by = list(m[,1],m[,2]),FUN=sum)
overallSSEdgesDF <- edgeDataSetup(overallSSEdgesDF)
for(i in 1:nrow(overallSSEdgesDF)) {
if(overallSSEdgesDF[i,"score"]>3){
overallSSEdgesDF[i,"mutual"]<- 2
}
overallSSEdgesDF[i,"mutual"]
}
overallSSEdgesDF
source("~/IBSCMasterFeedbackDash/SchoolDataPrep.R")
source("~/IBSCMasterFeedbackDash/SchoolDataPrep.R")
source("~/IBSCMasterFeedbackDash/SchoolDataPrep.R")
source("~/IBSCMasterFeedbackDash/SchoolDataPrep.R")
names(overallSSEdgesDF)
source("~/IBSCMasterFeedbackDash/SchoolDataPrep.R")
source("~/IBSCMasterFeedbackDash/SchoolDataPrep.R")
#source the D3 code to link the R to JS
source("assets/forcedirected/forcedirected.R")
